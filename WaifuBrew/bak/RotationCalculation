    // https://stackoverflow.com/questions/26175303/image-is-cutting-at-the-corners-after-rotating













    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);

        BufferedImage tempImage = transform(scrollingImage, xPos);
        g.drawImage(tempImage, 300, 300, this);
        // g.drawImage(scrollingImage, xPos, y, this);

        /*
        double locationX = scrollingImage.getWidth() / 2;
        double locationY = scrollingImage.getHeight() / 2;

        double diff = Math.abs(scrollingImage.getWidth() - scrollingImage.getHeight());

        double rotationRad = Math.toRadians(rotationDeg);
        double unitX = Math.abs(Math.cos(rotationRad));
        double unitY = Math.abs(Math.sin(rotationRad));

        double correctUx = unitX;
        double correctUy = unitY;

        if(scrollingImage.getWidth() < scrollingImage.getHeight()) {
            correctUx = unitY;
            correctUy = unitY;
        }

        int posAffineTransformOpX = xPos - (int)(locationX) - (int)(correctUx*diff);
        int posAffineTransformOpy = 300 - (int)(locationY - (int)(correctUy*diff));

        AffineTransform rotation = new AffineTransform();
        rotation.translate(correctUx*diff, correctUy*diff);
        rotation.rotate(Math.toRadians(rotationDeg), locationX, locationY);


        AffineTransformOp op = new AffineTransformOp(rotation, AffineTransformOp.TYPE_BICUBIC);
        // Apparently I can save the image through dst.
        g.drawImage(op.filter(scrollingImage, null), posAffineTransformOpX, posAffineTransformOpy, this);

        */














        /*

        double degreesToRotate = rotationDeg;
        double locationX = scrollingImage.getWidth() / 2;
        double locationY = scrollingImage.getHeight() / 2;

        double diff = Math.abs(scrollingImage.getWidth() - scrollingImage.getHeight());

//To correct the set of origin point and the overflow
        double rotationRequired = Math.toRadians(degreesToRotate);
        double unitX = Math.abs(Math.cos(rotationRequired));
        double unitY = Math.abs(Math.sin(rotationRequired));

        double correctUx = unitX;
        double correctUy = unitY;

//if the height is greater than the width, so you have to 'change' the axis to correct the overflow
        if(scrollingImage.getWidth() < scrollingImage.getHeight()){
            correctUx = unitY;
            correctUy = unitX;
        }

        int posAffineTransformOpX = xPos-(int)(locationX)-(int)(correctUx*diff);
        int posAffineTransformOpY = 300-(int)(locationY)-(int)(correctUy*diff);

//translate the image center to same diff that dislocates the origin, to correct its point set
        AffineTransform objTrans = new AffineTransform();
        objTrans.translate(correctUx*diff, correctUy*diff);
        objTrans.rotate(rotationRequired, locationX, locationY);

        AffineTransformOp op = new AffineTransformOp(objTrans, AffineTransformOp.TYPE_BILINEAR);

// Drawing the rotated image at the required drawing locations
        g.drawImage(op.filter(scrollingImage, null), posAffineTransformOpX, posAffineTransformOpY, null);

    */
    }


    public static BufferedImage transform(BufferedImage image, int numquadrants) {
        int w0 = image.getWidth();
        int h0 = image.getHeight();
        int w1 = w0;
        int h1 = h0;

        int centerX = w0 / 2;
        int centerY = h0 / 2;

        if (numquadrants % 2 == 1) {
            w1 = h0;
            h1 = w0;
        }

        if (numquadrants % 4 == 1) {
            if (w0 > h0) {
                centerX = h0 / 2;
                centerY = h0 / 2;
            } else if (h0 > w0) {
                centerX = w0 / 2;
                centerY = w0 / 2;
            }
            // if h0 == w0, then use default
        } else if (numquadrants % 4 == 3) {
            if (w0 > h0) {
                centerX = w0 / 2;
                centerY = w0 / 2;
            } else if (h0 > w0) {
                centerX = h0 / 2;
                centerY = h0 / 2;
            }
            // if h0 == w0, then use default
        }

        AffineTransform affineTransform = new AffineTransform();
        affineTransform.setToQuadrantRotation(numquadrants, centerX, centerY);

        AffineTransformOp opRotated = new AffineTransformOp(affineTransform,
                AffineTransformOp.TYPE_BILINEAR);

        BufferedImage transformedImage = new BufferedImage(w1, h1,
                image.getType());

        transformedImage = opRotated.filter(image, transformedImage);
        return transformedImage;
    }